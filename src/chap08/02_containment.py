# 자바의 복합관계 개념(has a ~)
# 상속에 전형적인 형태는 부모에 정의된 모든 필드와 기능 자체를 모두 상속을 받아서 마치 내 클래스 안에 정의된 것과 같은 효과를 가져간다는 것이다.
# 모든 관계를 반드시 상속의 관계로 정의를 해서 구조를 가져갈 수 있는 것은 아니다.
# 상속의 관계는 is a ~ 관계와 has a ~ 관계에서 고려해볼 수 있음
# is a같은 경우 a는 b다 -> 전형적인 다형성의 개념이다. is a관계일 때 다형성이 적용되어질 수 있는 것이였음. =>대표적으로 노트북은 컴퓨터다.
# 다음으로 상속의 관계를 고려할 수 있는 것이 has a 관계이다. => a has b: a는 b를 가지고 있다
# 여기서 주의해야 할 점은 예를 들어, 경찰은 모두 다 총을 가지고 있다라고할 때, 모든 경찰이 총을 가지고 있다면 상속의 관계를 성립할 수 있음
# 하지만 모든 경찰이라고 총을 다 가지고 있을 수는 없음. 직무에 따라서 총의 소지여부가 달라진다.
# 그러다 보니 has a 관계는 항상 상속의 관계 구조로 클래스를 정의한다는 것이 맞지 않을 수 있는 것이다.
# 하지만 군인을 생각해봤을 때, 군인은 개개인적으로 총을 다 소지할 수 있도록 지급이 되어짐. 그때에는 상속의 조건으로 정의를 하는 것이 유효함
# 이때, 상속의 관계가 적절하지 않은 has a 관계를 효율적으로 구조를 잡아가는 방법을 실습으로 살펴볼 것이다.

class A: #총
    def methodA(self):
        print("methodA() 호출")

class B: #여기서 총을 부모로 상속한다면 군인 -> 적합함 / 경찰 -> 적합하지 않음  ; 100%의 상속관계가 아니더라도 필드로 부모의 주소값을 저장해서 호출하는 것이 가능함.
    #자식의 독자적인 클래스에 개념으로 정의를 해주면서 필드에 부모의 A클래스에 인스턴스를 생성하도록 한다.
    #클래스 B입장에서는 참조변수를 선언하면서 A에 대한 메모리를 할당하고 필드에 주소값을 저장하도록 하는 것이다.
    def __init__(self):
        self.instance_of_A = A() #instance_of_A필드가 주소값을 보관할 수 있도록 함
        
    def call_methodA(self):
        self.instance_of_A.methodA() #A자료형에 있는 메소드를 호출할 수 있게됨 (생성자를 통하여 정의한 주소값이 저장된 필드를 통해서 메소드를 호출할 수 있다.)
        
if __name__ == '__main__':
    a = A()
    a.methodA()

    b = B()
    b.call_methodA()

# 독자적으로 클래스를 정의하더라도 상속의 구조를 만들어주면 다형성이나 메소드 오버라이딩 기능을 활용할 수 있기 때문에 그 시너지 효과를 극대화해서 가져갈 수 있지만
# 지금과 같이 상속의 관계가 100%가 아닐때는 개별적으로 클래스를 정의해서 자식의 개념으로 정의되어지는 클래스 안에서
# 필드로 부모로 사용하려 했던 클래스의 인스턴스를 생성해서 잘 보관하고 있다가 필요할때마다 메소드를 호출하는 형식으로도 활용을 많이 할 수 있다.